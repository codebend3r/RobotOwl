<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js\external\modernizr-2.6.2.js - RobotOwls</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="RobotOwls"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js\external\modernizr-2.6.2.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*!
 * Modernizr v2.6.2
 * www.modernizr.com
 *
 * Copyright (c) Faruk Ates, Paul Irish, Alex Sexton
 * Available under the BSD and MIT licenses: www.modernizr.com&#x2F;license&#x2F;
 *&#x2F;

&#x2F;*
 * Modernizr tests which native CSS3 and HTML5 features are available in
 * the current UA and makes the results available to you in two ways:
 * as properties on a global Modernizr object, and as classes on the
 * &lt;html&gt; element. This information allows you to progressively enhance
 * your pages with a granular level of control over the experience.
 *
 * Modernizr has an optional (not included) conditional resource loader
 * called Modernizr.load(), based on Yepnope.js (yepnopejs.com).
 * To get a build that includes Modernizr.load(), as well as choosing
 * which tests to include, go to www.modernizr.com&#x2F;download&#x2F;
 *
 * Authors        Faruk Ates, Paul Irish, Alex Sexton
 * Contributors   Ryan Seddon, Ben Alman
 *&#x2F;

window.Modernizr = (function( window, document, undefined ) {

    var version = &#x27;2.6.2&#x27;,

    Modernizr = {},

    &#x2F;*&gt;&gt;cssclasses*&#x2F;
    &#x2F;&#x2F; option for enabling the HTML classes to be added
    enableClasses = true,
    &#x2F;*&gt;&gt;cssclasses*&#x2F;

    docElement = document.documentElement,

    &#x2F;**
     * Create our &quot;modernizr&quot; element that we do most feature tests on.
     *&#x2F;
    mod = &#x27;modernizr&#x27;,
    modElem = document.createElement(mod),
    mStyle = modElem.style,

    &#x2F;**
     * Create the input element for various Web Forms feature tests.
     *&#x2F;
    inputElem &#x2F;*&gt;&gt;inputelem*&#x2F; = document.createElement(&#x27;input&#x27;) &#x2F;*&gt;&gt;inputelem*&#x2F; ,

    &#x2F;*&gt;&gt;smile*&#x2F;
    smile = &#x27;:)&#x27;,
    &#x2F;*&gt;&gt;smile*&#x2F;

    toString = {}.toString,

    &#x2F;&#x2F; TODO :: make the prefixes more granular
    &#x2F;*&gt;&gt;prefixes*&#x2F;
    &#x2F;&#x2F; List of property values to set for css tests. See ticket #21
    prefixes = &#x27; -webkit- -moz- -o- -ms- &#x27;.split(&#x27; &#x27;),
    &#x2F;*&gt;&gt;prefixes*&#x2F;

    &#x2F;*&gt;&gt;domprefixes*&#x2F;
    &#x2F;&#x2F; Following spec is to expose vendor-specific style properties as:
    &#x2F;&#x2F;   elem.style.WebkitBorderRadius
    &#x2F;&#x2F; and the following would be incorrect:
    &#x2F;&#x2F;   elem.style.webkitBorderRadius

    &#x2F;&#x2F; Webkit ghosts their properties in lowercase but Opera &amp; Moz do not.
    &#x2F;&#x2F; Microsoft uses a lowercase &#x60;ms&#x60; instead of the correct &#x60;Ms&#x60; in IE8+
    &#x2F;&#x2F;   erik.eae.net&#x2F;archives&#x2F;2008&#x2F;03&#x2F;10&#x2F;21.48.10&#x2F;

    &#x2F;&#x2F; More here: github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;issue&#x2F;21
    omPrefixes = &#x27;Webkit Moz O ms&#x27;,

    cssomPrefixes = omPrefixes.split(&#x27; &#x27;),

    domPrefixes = omPrefixes.toLowerCase().split(&#x27; &#x27;),
    &#x2F;*&gt;&gt;domprefixes*&#x2F;

    &#x2F;*&gt;&gt;ns*&#x2F;
    ns = {&#x27;svg&#x27;: &#x27;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#x27;},
    &#x2F;*&gt;&gt;ns*&#x2F;

    tests = {},
    inputs = {},
    attrs = {},

    classes = [],

    slice = classes.slice,

    featureName, &#x2F;&#x2F; used in testing loop


    &#x2F;*&gt;&gt;teststyles*&#x2F;
    &#x2F;&#x2F; Inject element with style element and some CSS rules
    injectElementWithStyles = function( rule, callback, nodes, testnames ) {

      var style, ret, node, docOverflow,
          div = document.createElement(&#x27;div&#x27;),
          &#x2F;&#x2F; After page load injecting a fake body doesn&#x27;t work so check if body exists
          body = document.body,
          &#x2F;&#x2F; IE6 and 7 won&#x27;t return offsetWidth or offsetHeight unless it&#x27;s in the body element, so we fake it.
          fakeBody = body || document.createElement(&#x27;body&#x27;);

      if ( parseInt(nodes, 10) ) {
          &#x2F;&#x2F; In order not to give false positives we create a node for each test
          &#x2F;&#x2F; This also allows the method to scale for unspecified uses
          while ( nodes-- ) {
              node = document.createElement(&#x27;div&#x27;);
              node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
              div.appendChild(node);
          }
      }

      &#x2F;&#x2F; &lt;style&gt; elements in IE6-9 are considered &#x27;NoScope&#x27; elements and therefore will be removed
      &#x2F;&#x2F; when injected with innerHTML. To get around this you need to prepend the &#x27;NoScope&#x27; element
      &#x2F;&#x2F; with a &#x27;scoped&#x27; element, in our case the soft-hyphen entity as it won&#x27;t mess with our measurements.
      &#x2F;&#x2F; msdn.microsoft.com&#x2F;en-us&#x2F;library&#x2F;ms533897%28VS.85%29.aspx
      &#x2F;&#x2F; Documents served as xml will throw if using &amp;shy; so use xml friendly encoded version. See issue #277
      style = [&#x27;&amp;#173;&#x27;,&#x27;&lt;style id=&quot;s&#x27;, mod, &#x27;&quot;&gt;&#x27;, rule, &#x27;&lt;&#x2F;style&gt;&#x27;].join(&#x27;&#x27;);
      div.id = mod;
      &#x2F;&#x2F; IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
      &#x2F;&#x2F; Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
      (body ? div : fakeBody).innerHTML += style;
      fakeBody.appendChild(div);
      if ( !body ) {
          &#x2F;&#x2F;avoid crashing IE8, if background image is used
          fakeBody.style.background = &#x27;&#x27;;
          &#x2F;&#x2F;Safari 5.13&#x2F;5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
          fakeBody.style.overflow = &#x27;hidden&#x27;;
          docOverflow = docElement.style.overflow;
          docElement.style.overflow = &#x27;hidden&#x27;;
          docElement.appendChild(fakeBody);
      }

      ret = callback(div, rule);
      &#x2F;&#x2F; If this is done after page load we don&#x27;t want to remove the body so check if body exists
      if ( !body ) {
          fakeBody.parentNode.removeChild(fakeBody);
          docElement.style.overflow = docOverflow;
      } else {
          div.parentNode.removeChild(div);
      }

      return !!ret;

    },
    &#x2F;*&gt;&gt;teststyles*&#x2F;

    &#x2F;*&gt;&gt;mq*&#x2F;
    &#x2F;&#x2F; adapted from matchMedia polyfill
    &#x2F;&#x2F; by Scott Jehl and Paul Irish
    &#x2F;&#x2F; gist.github.com&#x2F;786768
    testMediaQuery = function( mq ) {

      var matchMedia = window.matchMedia || window.msMatchMedia;
      if ( matchMedia ) {
        return matchMedia(mq).matches;
      }

      var bool;

      injectElementWithStyles(&#x27;@media &#x27; + mq + &#x27; { #&#x27; + mod + &#x27; { position: absolute; } }&#x27;, function( node ) {
        bool = (window.getComputedStyle ?
                  getComputedStyle(node, null) :
                  node.currentStyle)[&#x27;position&#x27;] == &#x27;absolute&#x27;;
      });

      return bool;

     },
     &#x2F;*&gt;&gt;mq*&#x2F;


    &#x2F;*&gt;&gt;hasevent*&#x2F;
    &#x2F;&#x2F;
    &#x2F;&#x2F; isEventSupported determines if a given element supports the given event
    &#x2F;&#x2F; kangax.github.com&#x2F;iseventsupported&#x2F;
    &#x2F;&#x2F;
    &#x2F;&#x2F; The following results are known incorrects:
    &#x2F;&#x2F;   Modernizr.hasEvent(&quot;webkitTransitionEnd&quot;, elem) &#x2F;&#x2F; false negative
    &#x2F;&#x2F;   Modernizr.hasEvent(&quot;textInput&quot;) &#x2F;&#x2F; in Webkit. github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;333
    &#x2F;&#x2F;   ...
    isEventSupported = (function() {

      var TAGNAMES = {
        &#x27;select&#x27;: &#x27;input&#x27;, &#x27;change&#x27;: &#x27;input&#x27;,
        &#x27;submit&#x27;: &#x27;form&#x27;, &#x27;reset&#x27;: &#x27;form&#x27;,
        &#x27;error&#x27;: &#x27;img&#x27;, &#x27;load&#x27;: &#x27;img&#x27;, &#x27;abort&#x27;: &#x27;img&#x27;
      };

      function isEventSupported( eventName, element ) {

        element = element || document.createElement(TAGNAMES[eventName] || &#x27;div&#x27;);
        eventName = &#x27;on&#x27; + eventName;

        &#x2F;&#x2F; When using &#x60;setAttribute&#x60;, IE skips &quot;unload&quot;, WebKit skips &quot;unload&quot; and &quot;resize&quot;, whereas &#x60;in&#x60; &quot;catches&quot; those
        var isSupported = eventName in element;

        if ( !isSupported ) {
          &#x2F;&#x2F; If it has no &#x60;setAttribute&#x60; (i.e. doesn&#x27;t implement Node interface), try generic element
          if ( !element.setAttribute ) {
            element = document.createElement(&#x27;div&#x27;);
          }
          if ( element.setAttribute &amp;&amp; element.removeAttribute ) {
            element.setAttribute(eventName, &#x27;&#x27;);
            isSupported = is(element[eventName], &#x27;function&#x27;);

            &#x2F;&#x2F; If property was created, &quot;remove it&quot; (by setting value to &#x60;undefined&#x60;)
            if ( !is(element[eventName], &#x27;undefined&#x27;) ) {
              element[eventName] = undefined;
            }
            element.removeAttribute(eventName);
          }
        }

        element = null;
        return isSupported;
      }
      return isEventSupported;
    })(),
    &#x2F;*&gt;&gt;hasevent*&#x2F;

    &#x2F;&#x2F; TODO :: Add flag for hasownprop ? didn&#x27;t last time

    &#x2F;&#x2F; hasOwnProperty shim by kangax needed for Safari 2.0 support
    _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;

    if ( !is(_hasOwnProperty, &#x27;undefined&#x27;) &amp;&amp; !is(_hasOwnProperty.call, &#x27;undefined&#x27;) ) {
      hasOwnProp = function (object, property) {
        return _hasOwnProperty.call(object, property);
      };
    }
    else {
      hasOwnProp = function (object, property) { &#x2F;* yes, this can give false positives&#x2F;negatives, but most of the time we don&#x27;t care about those *&#x2F;
        return ((property in object) &amp;&amp; is(object.constructor.prototype[property], &#x27;undefined&#x27;));
      };
    }

    &#x2F;&#x2F; Adapted from ES5-shim https:&#x2F;&#x2F;github.com&#x2F;kriskowal&#x2F;es5-shim&#x2F;blob&#x2F;master&#x2F;es5-shim.js
    &#x2F;&#x2F; es5.github.com&#x2F;#x15.3.4.5

    if (!Function.prototype.bind) {
      Function.prototype.bind = function bind(that) {

        var target = this;

        if (typeof target != &quot;function&quot;) {
            throw new TypeError();
        }

        var args = slice.call(arguments, 1),
            bound = function () {

            if (this instanceof bound) {

              var F = function(){};
              F.prototype = target.prototype;
              var self = new F();

              var result = target.apply(
                  self,
                  args.concat(slice.call(arguments))
              );
              if (Object(result) === result) {
                  return result;
              }
              return self;

            } else {

              return target.apply(
                  that,
                  args.concat(slice.call(arguments))
              );

            }

        };

        return bound;
      };
    }

    &#x2F;**
     * setCss applies given styles to the Modernizr DOM node.
     *&#x2F;
    function setCss( str ) {
        mStyle.cssText = str;
    }

    &#x2F;**
     * setCssAll extrapolates all vendor-specific css strings.
     *&#x2F;
    function setCssAll( str1, str2 ) {
        return setCss(prefixes.join(str1 + &#x27;;&#x27;) + ( str2 || &#x27;&#x27; ));
    }

    &#x2F;**
     * is returns a boolean for if typeof obj is exactly type.
     *&#x2F;
    function is( obj, type ) {
        return typeof obj === type;
    }

    &#x2F;**
     * contains returns a boolean for if substr is found within str.
     *&#x2F;
    function contains( str, substr ) {
        return !!~(&#x27;&#x27; + str).indexOf(substr);
    }

    &#x2F;*&gt;&gt;testprop*&#x2F;

    &#x2F;&#x2F; testProps is a generic CSS &#x2F; DOM property test.

    &#x2F;&#x2F; In testing support for a given CSS property, it&#x27;s legit to test:
    &#x2F;&#x2F;    &#x60;elem.style[styleName] !== undefined&#x60;
    &#x2F;&#x2F; If the property is supported it will return an empty string,
    &#x2F;&#x2F; if unsupported it will return undefined.

    &#x2F;&#x2F; We&#x27;ll take advantage of this quick test and skip setting a style
    &#x2F;&#x2F; on our modernizr element, but instead just testing undefined vs
    &#x2F;&#x2F; empty string.

    &#x2F;&#x2F; Because the testing of the CSS property names (with &quot;-&quot;, as
    &#x2F;&#x2F; opposed to the camelCase DOM properties) is non-portable and
    &#x2F;&#x2F; non-standard but works in WebKit and IE (but not Gecko or Opera),
    &#x2F;&#x2F; we explicitly reject properties with dashes so that authors
    &#x2F;&#x2F; developing in WebKit or IE first don&#x27;t end up with
    &#x2F;&#x2F; browser-specific content by accident.

    function testProps( props, prefixed ) {
        for ( var i in props ) {
            var prop = props[i];
            if ( !contains(prop, &quot;-&quot;) &amp;&amp; mStyle[prop] !== undefined ) {
                return prefixed == &#x27;pfx&#x27; ? prop : true;
            }
        }
        return false;
    }
    &#x2F;*&gt;&gt;testprop*&#x2F;

    &#x2F;&#x2F; TODO :: add testDOMProps
    &#x2F;**
     * testDOMProps is a generic DOM property test; if a browser supports
     *   a certain property, it won&#x27;t return undefined for it.
     *&#x2F;
    function testDOMProps( props, obj, elem ) {
        for ( var i in props ) {
            var item = obj[props[i]];
            if ( item !== undefined) {

                &#x2F;&#x2F; return the property slug as a string
                if (elem === false) return props[i];

                &#x2F;&#x2F; let&#x27;s bind a function
                if (is(item, &#x27;function&#x27;)){
                  &#x2F;&#x2F; default to autobind unless override
                  return item.bind(elem || obj);
                }

                &#x2F;&#x2F; return the unbound function or obj or value
                return item;
            }
        }
        return false;
    }

    &#x2F;*&gt;&gt;testallprops*&#x2F;
    &#x2F;**
     * testPropsAll tests a list of DOM properties we want to check against.
     *   We specify literally ALL possible (known and&#x2F;or likely) properties on
     *   the element including the non-vendor prefixed one, for forward-
     *   compatibility.
     *&#x2F;
    function testPropsAll( prop, prefixed, elem ) {

        var ucProp  = prop.charAt(0).toUpperCase() + prop.slice(1),
            props   = (prop + &#x27; &#x27; + cssomPrefixes.join(ucProp + &#x27; &#x27;) + ucProp).split(&#x27; &#x27;);

        &#x2F;&#x2F; did they call .prefixed(&#x27;boxSizing&#x27;) or are we just testing a prop?
        if(is(prefixed, &quot;string&quot;) || is(prefixed, &quot;undefined&quot;)) {
          return testProps(props, prefixed);

        &#x2F;&#x2F; otherwise, they called .prefixed(&#x27;requestAnimationFrame&#x27;, window[, elem])
        } else {
          props = (prop + &#x27; &#x27; + (domPrefixes).join(ucProp + &#x27; &#x27;) + ucProp).split(&#x27; &#x27;);
          return testDOMProps(props, prefixed, elem);
        }
    }
    &#x2F;*&gt;&gt;testallprops*&#x2F;


    &#x2F;**
     * Tests
     * -----
     *&#x2F;

    &#x2F;&#x2F; The *new* flexbox
    &#x2F;&#x2F; dev.w3.org&#x2F;csswg&#x2F;css3-flexbox

    tests[&#x27;flexbox&#x27;] = function() {
      return testPropsAll(&#x27;flexWrap&#x27;);
    };

    &#x2F;&#x2F; The *old* flexbox
    &#x2F;&#x2F; www.w3.org&#x2F;TR&#x2F;2009&#x2F;WD-css3-flexbox-20090723&#x2F;

    tests[&#x27;flexboxlegacy&#x27;] = function() {
        return testPropsAll(&#x27;boxDirection&#x27;);
    };

    &#x2F;&#x2F; On the S60 and BB Storm, getContext exists, but always returns undefined
    &#x2F;&#x2F; so we actually have to call getContext() to verify
    &#x2F;&#x2F; github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;issue&#x2F;97&#x2F;

    tests[&#x27;canvas&#x27;] = function() {
        var elem = document.createElement(&#x27;canvas&#x27;);
        return !!(elem.getContext &amp;&amp; elem.getContext(&#x27;2d&#x27;));
    };

    tests[&#x27;canvastext&#x27;] = function() {
        return !!(Modernizr[&#x27;canvas&#x27;] &amp;&amp; is(document.createElement(&#x27;canvas&#x27;).getContext(&#x27;2d&#x27;).fillText, &#x27;function&#x27;));
    };

    &#x2F;&#x2F; webk.it&#x2F;70117 is tracking a legit WebGL feature detect proposal

    &#x2F;&#x2F; We do a soft detect which may false positive in order to avoid
    &#x2F;&#x2F; an expensive context creation: bugzil.la&#x2F;732441

    tests[&#x27;webgl&#x27;] = function() {
        return !!window.WebGLRenderingContext;
    };

    &#x2F;*
     * The Modernizr.touch test only indicates if the browser supports
     *    touch events, which does not necessarily reflect a touchscreen
     *    device, as evidenced by tablets running Windows 7 or, alas,
     *    the Palm Pre &#x2F; WebOS (touch) phones.
     *
     * Additionally, Chrome (desktop) used to lie about its support on this,
     *    but that has since been rectified: crbug.com&#x2F;36415
     *
     * We also test for Firefox 4 Multitouch Support.
     *
     * For more info, see: modernizr.github.com&#x2F;Modernizr&#x2F;touch.html
     *&#x2F;

    tests[&#x27;touch&#x27;] = function() {
        var bool;

        if((&#x27;ontouchstart&#x27; in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch) {
          bool = true;
        } else {
          injectElementWithStyles([&#x27;@media (&#x27;,prefixes.join(&#x27;touch-enabled),(&#x27;),mod,&#x27;)&#x27;,&#x27;{#modernizr{top:9px;position:absolute}}&#x27;].join(&#x27;&#x27;), function( node ) {
            bool = node.offsetTop === 9;
          });
        }

        return bool;
    };


    &#x2F;&#x2F; geolocation is often considered a trivial feature detect...
    &#x2F;&#x2F; Turns out, it&#x27;s quite tricky to get right:
    &#x2F;&#x2F;
    &#x2F;&#x2F; Using !!navigator.geolocation does two things we don&#x27;t want. It:
    &#x2F;&#x2F;   1. Leaks memory in IE9: github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;513
    &#x2F;&#x2F;   2. Disables page caching in WebKit: webk.it&#x2F;43956
    &#x2F;&#x2F;
    &#x2F;&#x2F; Meanwhile, in Firefox &lt; 8, an about:config setting could expose
    &#x2F;&#x2F; a false positive that would throw an exception: bugzil.la&#x2F;688158

    tests[&#x27;geolocation&#x27;] = function() {
        return &#x27;geolocation&#x27; in navigator;
    };


    tests[&#x27;postmessage&#x27;] = function() {
      return !!window.postMessage;
    };


    &#x2F;&#x2F; Chrome incognito mode used to throw an exception when using openDatabase
    &#x2F;&#x2F; It doesn&#x27;t anymore.
    tests[&#x27;websqldatabase&#x27;] = function() {
      return !!window.openDatabase;
    };

    &#x2F;&#x2F; Vendors had inconsistent prefixing with the experimental Indexed DB:
    &#x2F;&#x2F; - Webkit&#x27;s implementation is accessible through webkitIndexedDB
    &#x2F;&#x2F; - Firefox shipped moz_indexedDB before FF4b9, but since then has been mozIndexedDB
    &#x2F;&#x2F; For speed, we don&#x27;t test the legacy (and beta-only) indexedDB
    tests[&#x27;indexedDB&#x27;] = function() {
      return !!testPropsAll(&quot;indexedDB&quot;, window);
    };

    &#x2F;&#x2F; documentMode logic from YUI to filter out IE8 Compat Mode
    &#x2F;&#x2F;   which false positives.
    tests[&#x27;hashchange&#x27;] = function() {
      return isEventSupported(&#x27;hashchange&#x27;, window) &amp;&amp; (document.documentMode === undefined || document.documentMode &gt; 7);
    };

    &#x2F;&#x2F; Per 1.6:
    &#x2F;&#x2F; This used to be Modernizr.historymanagement but the longer
    &#x2F;&#x2F; slug has been deprecated in favor of a shorter and property-matching one.
    &#x2F;&#x2F; The old API is still available in 1.6, but as of 2.0 will throw a warning,
    &#x2F;&#x2F; and in the first release thereafter disappear entirely.
    tests[&#x27;history&#x27;] = function() {
      return !!(window.history &amp;&amp; history.pushState);
    };

    tests[&#x27;draganddrop&#x27;] = function() {
        var div = document.createElement(&#x27;div&#x27;);
        return (&#x27;draggable&#x27; in div) || (&#x27;ondragstart&#x27; in div &amp;&amp; &#x27;ondrop&#x27; in div);
    };

    &#x2F;&#x2F; FF3.6 was EOL&#x27;ed on 4&#x2F;24&#x2F;12, but the ESR version of FF10
    &#x2F;&#x2F; will be supported until FF19 (2&#x2F;12&#x2F;13), at which time, ESR becomes FF17.
    &#x2F;&#x2F; FF10 still uses prefixes, so check for it until then.
    &#x2F;&#x2F; for more ESR info, see: mozilla.org&#x2F;en-US&#x2F;firefox&#x2F;organizations&#x2F;faq&#x2F;
    tests[&#x27;websockets&#x27;] = function() {
        return &#x27;WebSocket&#x27; in window || &#x27;MozWebSocket&#x27; in window;
    };


    &#x2F;&#x2F; css-tricks.com&#x2F;rgba-browser-support&#x2F;
    tests[&#x27;rgba&#x27;] = function() {
        &#x2F;&#x2F; Set an rgba() color and check the returned value

        setCss(&#x27;background-color:rgba(150,255,150,.5)&#x27;);

        return contains(mStyle.backgroundColor, &#x27;rgba&#x27;);
    };

    tests[&#x27;hsla&#x27;] = function() {
        &#x2F;&#x2F; Same as rgba(), in fact, browsers re-map hsla() to rgba() internally,
        &#x2F;&#x2F;   except IE9 who retains it as hsla

        setCss(&#x27;background-color:hsla(120,40%,100%,.5)&#x27;);

        return contains(mStyle.backgroundColor, &#x27;rgba&#x27;) || contains(mStyle.backgroundColor, &#x27;hsla&#x27;);
    };

    tests[&#x27;multiplebgs&#x27;] = function() {
        &#x2F;&#x2F; Setting multiple images AND a color on the background shorthand property
        &#x2F;&#x2F;  and then querying the style.background property value for the number of
        &#x2F;&#x2F;  occurrences of &quot;url(&quot; is a reliable method for detecting ACTUAL support for this!

        setCss(&#x27;background:url(https:&#x2F;&#x2F;),url(https:&#x2F;&#x2F;),red url(https:&#x2F;&#x2F;)&#x27;);

        &#x2F;&#x2F; If the UA supports multiple backgrounds, there should be three occurrences
        &#x2F;&#x2F;   of the string &quot;url(&quot; in the return value for elemStyle.background

        return (&#x2F;(url\s*\(.*?){3}&#x2F;).test(mStyle.background);
    };



    &#x2F;&#x2F; this will false positive in Opera Mini
    &#x2F;&#x2F;   github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;396

    tests[&#x27;backgroundsize&#x27;] = function() {
        return testPropsAll(&#x27;backgroundSize&#x27;);
    };

    tests[&#x27;borderimage&#x27;] = function() {
        return testPropsAll(&#x27;borderImage&#x27;);
    };


    &#x2F;&#x2F; Super comprehensive table about all the unique implementations of
    &#x2F;&#x2F; border-radius: muddledramblings.com&#x2F;table-of-css3-border-radius-compliance

    tests[&#x27;borderradius&#x27;] = function() {
        return testPropsAll(&#x27;borderRadius&#x27;);
    };

    &#x2F;&#x2F; WebOS unfortunately false positives on this test.
    tests[&#x27;boxshadow&#x27;] = function() {
        return testPropsAll(&#x27;boxShadow&#x27;);
    };

    &#x2F;&#x2F; FF3.0 will false positive on this test
    tests[&#x27;textshadow&#x27;] = function() {
        return document.createElement(&#x27;div&#x27;).style.textShadow === &#x27;&#x27;;
    };


    tests[&#x27;opacity&#x27;] = function() {
        &#x2F;&#x2F; Browsers that actually have CSS Opacity implemented have done so
        &#x2F;&#x2F;  according to spec, which means their return values are within the
        &#x2F;&#x2F;  range of [0.0,1.0] - including the leading zero.

        setCssAll(&#x27;opacity:.55&#x27;);

        &#x2F;&#x2F; The non-literal . in this regex is intentional:
        &#x2F;&#x2F;   German Chrome returns this value as 0,55
        &#x2F;&#x2F; github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;#issue&#x2F;59&#x2F;comment&#x2F;516632
        return (&#x2F;^0.55$&#x2F;).test(mStyle.opacity);
    };


    &#x2F;&#x2F; Note, Android &lt; 4 will pass this test, but can only animate
    &#x2F;&#x2F;   a single property at a time
    &#x2F;&#x2F;   daneden.me&#x2F;2011&#x2F;12&#x2F;putting-up-with-androids-bullshit&#x2F;
    tests[&#x27;cssanimations&#x27;] = function() {
        return testPropsAll(&#x27;animationName&#x27;);
    };


    tests[&#x27;csscolumns&#x27;] = function() {
        return testPropsAll(&#x27;columnCount&#x27;);
    };


    tests[&#x27;cssgradients&#x27;] = function() {
        &#x2F;**
         * For CSS Gradients syntax, please see:
         * webkit.org&#x2F;blog&#x2F;175&#x2F;introducing-css-gradients&#x2F;
         * developer.mozilla.org&#x2F;en&#x2F;CSS&#x2F;-moz-linear-gradient
         * developer.mozilla.org&#x2F;en&#x2F;CSS&#x2F;-moz-radial-gradient
         * dev.w3.org&#x2F;csswg&#x2F;css3-images&#x2F;#gradients-
         *&#x2F;

        var str1 = &#x27;background-image:&#x27;,
            str2 = &#x27;gradient(linear,left top,right bottom,from(#9f9),to(white));&#x27;,
            str3 = &#x27;linear-gradient(left top,#9f9, white);&#x27;;

        setCss(
             &#x2F;&#x2F; legacy webkit syntax (FIXME: remove when syntax not in use anymore)
              (str1 + &#x27;-webkit- &#x27;.split(&#x27; &#x27;).join(str2 + str1) +
             &#x2F;&#x2F; standard syntax             &#x2F;&#x2F; trailing &#x27;background-image:&#x27;
              prefixes.join(str3 + str1)).slice(0, -str1.length)
        );

        return contains(mStyle.backgroundImage, &#x27;gradient&#x27;);
    };


    tests[&#x27;cssreflections&#x27;] = function() {
        return testPropsAll(&#x27;boxReflect&#x27;);
    };


    tests[&#x27;csstransforms&#x27;] = function() {
        return !!testPropsAll(&#x27;transform&#x27;);
    };


    tests[&#x27;csstransforms3d&#x27;] = function() {

        var ret = !!testPropsAll(&#x27;perspective&#x27;);

        &#x2F;&#x2F; Webkit&#x27;s 3D transforms are passed off to the browser&#x27;s own graphics renderer.
        &#x2F;&#x2F;   It works fine in Safari on Leopard and Snow Leopard, but not in Chrome in
        &#x2F;&#x2F;   some conditions. As a result, Webkit typically recognizes the syntax but
        &#x2F;&#x2F;   will sometimes throw a false positive, thus we must do a more thorough check:
        if ( ret &amp;&amp; &#x27;webkitPerspective&#x27; in docElement.style ) {

          &#x2F;&#x2F; Webkit allows this media query to succeed only if the feature is enabled.
          &#x2F;&#x2F; &#x60;@media (transform-3d),(-webkit-transform-3d){ ... }&#x60;
          injectElementWithStyles(&#x27;@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}&#x27;, function( node, rule ) {
            ret = node.offsetLeft === 9 &amp;&amp; node.offsetHeight === 3;
          });
        }
        return ret;
    };


    tests[&#x27;csstransitions&#x27;] = function() {
        return testPropsAll(&#x27;transition&#x27;);
    };


    &#x2F;*&gt;&gt;fontface*&#x2F;
    &#x2F;&#x2F; @font-face detection routine by Diego Perini
    &#x2F;&#x2F; javascript.nwbox.com&#x2F;CSSSupport&#x2F;

    &#x2F;&#x2F; false positives:
    &#x2F;&#x2F;   WebOS github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;342
    &#x2F;&#x2F;   WP7   github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;538
    tests[&#x27;fontface&#x27;] = function() {
        var bool;

        injectElementWithStyles(&#x27;@font-face {font-family:&quot;font&quot;;src:url(&quot;https:&#x2F;&#x2F;&quot;)}&#x27;, function( node, rule ) {
          var style = document.getElementById(&#x27;smodernizr&#x27;),
              sheet = style.sheet || style.styleSheet,
              cssText = sheet ? (sheet.cssRules &amp;&amp; sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || &#x27;&#x27;) : &#x27;&#x27;;

          bool = &#x2F;src&#x2F;i.test(cssText) &amp;&amp; cssText.indexOf(rule.split(&#x27; &#x27;)[0]) === 0;
        });

        return bool;
    };
    &#x2F;*&gt;&gt;fontface*&#x2F;

    &#x2F;&#x2F; CSS generated content detection
    tests[&#x27;generatedcontent&#x27;] = function() {
        var bool;

        injectElementWithStyles([&#x27;#&#x27;,mod,&#x27;{font:0&#x2F;0 a}#&#x27;,mod,&#x27;:after{content:&quot;&#x27;,smile,&#x27;&quot;;visibility:hidden;font:3px&#x2F;1 a}&#x27;].join(&#x27;&#x27;), function( node ) {
          bool = node.offsetHeight &gt;= 3;
        });

        return bool;
    };



    &#x2F;&#x2F; These tests evaluate support of the video&#x2F;audio elements, as well as
    &#x2F;&#x2F; testing what types of content they support.
    &#x2F;&#x2F;
    &#x2F;&#x2F; We&#x27;re using the Boolean constructor here, so that we can extend the value
    &#x2F;&#x2F; e.g.  Modernizr.video     &#x2F;&#x2F; true
    &#x2F;&#x2F;       Modernizr.video.ogg &#x2F;&#x2F; &#x27;probably&#x27;
    &#x2F;&#x2F;
    &#x2F;&#x2F; Codec values from : github.com&#x2F;NielsLeenheer&#x2F;html5test&#x2F;blob&#x2F;9106a8&#x2F;index.html#L845
    &#x2F;&#x2F;                     thx to NielsLeenheer and zcorpan

    &#x2F;&#x2F; Note: in some older browsers, &quot;no&quot; was a return value instead of empty string.
    &#x2F;&#x2F;   It was live in FF3.5.0 and 3.5.1, but fixed in 3.5.2
    &#x2F;&#x2F;   It was also live in Safari 4.0.0 - 4.0.4, but fixed in 4.0.5

    tests[&#x27;video&#x27;] = function() {
        var elem = document.createElement(&#x27;video&#x27;),
            bool = false;

        &#x2F;&#x2F; IE9 Running on Windows Server SKU can cause an exception to be thrown, bug #224
        try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType(&#x27;video&#x2F;ogg; codecs=&quot;theora&quot;&#x27;)      .replace(&#x2F;^no$&#x2F;,&#x27;&#x27;);

                &#x2F;&#x2F; Without QuickTime, this value will be &#x60;undefined&#x60;. github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;546
                bool.h264 = elem.canPlayType(&#x27;video&#x2F;mp4; codecs=&quot;avc1.42E01E&quot;&#x27;) .replace(&#x2F;^no$&#x2F;,&#x27;&#x27;);

                bool.webm = elem.canPlayType(&#x27;video&#x2F;webm; codecs=&quot;vp8, vorbis&quot;&#x27;).replace(&#x2F;^no$&#x2F;,&#x27;&#x27;);
            }

        } catch(e) { }

        return bool;
    };

    tests[&#x27;audio&#x27;] = function() {
        var elem = document.createElement(&#x27;audio&#x27;),
            bool = false;

        try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType(&#x27;audio&#x2F;ogg; codecs=&quot;vorbis&quot;&#x27;).replace(&#x2F;^no$&#x2F;,&#x27;&#x27;);
                bool.mp3  = elem.canPlayType(&#x27;audio&#x2F;mpeg;&#x27;)               .replace(&#x2F;^no$&#x2F;,&#x27;&#x27;);

                &#x2F;&#x2F; Mimetypes accepted:
                &#x2F;&#x2F;   developer.mozilla.org&#x2F;En&#x2F;Media_formats_supported_by_the_audio_and_video_elements
                &#x2F;&#x2F;   bit.ly&#x2F;iphoneoscodecs
                bool.wav  = elem.canPlayType(&#x27;audio&#x2F;wav; codecs=&quot;1&quot;&#x27;)     .replace(&#x2F;^no$&#x2F;,&#x27;&#x27;);
                bool.m4a  = ( elem.canPlayType(&#x27;audio&#x2F;x-m4a;&#x27;)            ||
                              elem.canPlayType(&#x27;audio&#x2F;aac;&#x27;))             .replace(&#x2F;^no$&#x2F;,&#x27;&#x27;);
            }
        } catch(e) { }

        return bool;
    };


    &#x2F;&#x2F; In FF4, if disabled, window.localStorage should === null.

    &#x2F;&#x2F; Normally, we could not test that directly and need to do a
    &#x2F;&#x2F;   &#x60;(&#x27;localStorage&#x27; in window) &amp;&amp; &#x60; test first because otherwise Firefox will
    &#x2F;&#x2F;   throw bugzil.la&#x2F;365772 if cookies are disabled

    &#x2F;&#x2F; Also in iOS5 Private Browsing mode, attempting to use localStorage.setItem
    &#x2F;&#x2F; will throw the exception:
    &#x2F;&#x2F;   QUOTA_EXCEEDED_ERRROR DOM Exception 22.
    &#x2F;&#x2F; Peculiarly, getItem and removeItem calls do not throw.

    &#x2F;&#x2F; Because we are forced to try&#x2F;catch this, we&#x27;ll go aggressive.

    &#x2F;&#x2F; Just FWIW: IE8 Compat mode supports these features completely:
    &#x2F;&#x2F;   www.quirksmode.org&#x2F;dom&#x2F;html5.html
    &#x2F;&#x2F; But IE8 doesn&#x27;t support either with local files

    tests[&#x27;localstorage&#x27;] = function() {
        try {
            localStorage.setItem(mod, mod);
            localStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };

    tests[&#x27;sessionstorage&#x27;] = function() {
        try {
            sessionStorage.setItem(mod, mod);
            sessionStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };


    tests[&#x27;webworkers&#x27;] = function() {
        return !!window.Worker;
    };


    tests[&#x27;applicationcache&#x27;] = function() {
        return !!window.applicationCache;
    };


    &#x2F;&#x2F; Thanks to Erik Dahlstrom
    tests[&#x27;svg&#x27;] = function() {
        return !!document.createElementNS &amp;&amp; !!document.createElementNS(ns.svg, &#x27;svg&#x27;).createSVGRect;
    };

    &#x2F;&#x2F; specifically for SVG inline in HTML, not within XHTML
    &#x2F;&#x2F; test page: paulirish.com&#x2F;demo&#x2F;inline-svg
    tests[&#x27;inlinesvg&#x27;] = function() {
      var div = document.createElement(&#x27;div&#x27;);
      div.innerHTML = &#x27;&lt;svg&#x2F;&gt;&#x27;;
      return (div.firstChild &amp;&amp; div.firstChild.namespaceURI) == ns.svg;
    };

    &#x2F;&#x2F; SVG SMIL animation
    tests[&#x27;smil&#x27;] = function() {
        return !!document.createElementNS &amp;&amp; &#x2F;SVGAnimate&#x2F;.test(toString.call(document.createElementNS(ns.svg, &#x27;animate&#x27;)));
    };

    &#x2F;&#x2F; This test is only for clip paths in SVG proper, not clip paths on HTML content
    &#x2F;&#x2F; demo: srufaculty.sru.edu&#x2F;david.dailey&#x2F;svg&#x2F;newstuff&#x2F;clipPath4.svg

    &#x2F;&#x2F; However read the comments to dig into applying SVG clippaths to HTML content here:
    &#x2F;&#x2F;   github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;213#issuecomment-1149491
    tests[&#x27;svgclippaths&#x27;] = function() {
        return !!document.createElementNS &amp;&amp; &#x2F;SVGClipPath&#x2F;.test(toString.call(document.createElementNS(ns.svg, &#x27;clipPath&#x27;)));
    };

    &#x2F;*&gt;&gt;webforms*&#x2F;
    &#x2F;&#x2F; input features and input types go directly onto the ret object, bypassing the tests loop.
    &#x2F;&#x2F; Hold this guy to execute in a moment.
    function webforms() {
        &#x2F;*&gt;&gt;input*&#x2F;
        &#x2F;&#x2F; Run through HTML5&#x27;s new input attributes to see if the UA understands any.
        &#x2F;&#x2F; We&#x27;re using f which is the &lt;input&gt; element created early on
        &#x2F;&#x2F; Mike Taylr has created a comprehensive resource for testing these attributes
        &#x2F;&#x2F;   when applied to all input types:
        &#x2F;&#x2F;   miketaylr.com&#x2F;code&#x2F;input-type-attr.html
        &#x2F;&#x2F; spec: www.whatwg.org&#x2F;specs&#x2F;web-apps&#x2F;current-work&#x2F;multipage&#x2F;the-input-element.html#input-type-attr-summary

        &#x2F;&#x2F; Only input placeholder is tested while textarea&#x27;s placeholder is not.
        &#x2F;&#x2F; Currently Safari 4 and Opera 11 have support only for the input placeholder
        &#x2F;&#x2F; Both tests are available in feature-detects&#x2F;forms-placeholder.js
        Modernizr[&#x27;input&#x27;] = (function( props ) {
            for ( var i = 0, len = props.length; i &lt; len; i++ ) {
                attrs[ props[i] ] = !!(props[i] in inputElem);
            }
            if (attrs.list){
              &#x2F;&#x2F; safari false positive&#x27;s on datalist: webk.it&#x2F;74252
              &#x2F;&#x2F; see also github.com&#x2F;Modernizr&#x2F;Modernizr&#x2F;issues&#x2F;146
              attrs.list = !!(document.createElement(&#x27;datalist&#x27;) &amp;&amp; window.HTMLDataListElement);
            }
            return attrs;
        })(&#x27;autocomplete autofocus list placeholder max min multiple pattern required step&#x27;.split(&#x27; &#x27;));
        &#x2F;*&gt;&gt;input*&#x2F;

        &#x2F;*&gt;&gt;inputtypes*&#x2F;
        &#x2F;&#x2F; Run through HTML5&#x27;s new input types to see if the UA understands any.
        &#x2F;&#x2F;   This is put behind the tests runloop because it doesn&#x27;t return a
        &#x2F;&#x2F;   true&#x2F;false like all the other tests; instead, it returns an object
        &#x2F;&#x2F;   containing each input type with its corresponding true&#x2F;false value

        &#x2F;&#x2F; Big thanks to @miketaylr for the html5 forms expertise. miketaylr.com&#x2F;
        Modernizr[&#x27;inputtypes&#x27;] = (function(props) {

            for ( var i = 0, bool, inputElemType, defaultView, len = props.length; i &lt; len; i++ ) {

                inputElem.setAttribute(&#x27;type&#x27;, inputElemType = props[i]);
                bool = inputElem.type !== &#x27;text&#x27;;

                &#x2F;&#x2F; We first check to see if the type we give it sticks..
                &#x2F;&#x2F; If the type does, we feed it a textual value, which shouldn&#x27;t be valid.
                &#x2F;&#x2F; If the value doesn&#x27;t stick, we know there&#x27;s input sanitization which infers a custom UI
                if ( bool ) {

                    inputElem.value         = smile;
                    inputElem.style.cssText = &#x27;position:absolute;visibility:hidden;&#x27;;

                    if ( &#x2F;^range$&#x2F;.test(inputElemType) &amp;&amp; inputElem.style.WebkitAppearance !== undefined ) {

                      docElement.appendChild(inputElem);
                      defaultView = document.defaultView;

                      &#x2F;&#x2F; Safari 2-4 allows the smiley as a value, despite making a slider
                      bool =  defaultView.getComputedStyle &amp;&amp;
                              defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== &#x27;textfield&#x27; &amp;&amp;
                              &#x2F;&#x2F; Mobile android web browser has false positive, so must
                              &#x2F;&#x2F; check the height to see if the widget is actually there.
                              (inputElem.offsetHeight !== 0);

                      docElement.removeChild(inputElem);

                    } else if ( &#x2F;^(search|tel)$&#x2F;.test(inputElemType) ){
                      &#x2F;&#x2F; Spec doesn&#x27;t define any special parsing or detectable UI
                      &#x2F;&#x2F;   behaviors so we pass these through as true

                      &#x2F;&#x2F; Interestingly, opera fails the earlier test, so it doesn&#x27;t
                      &#x2F;&#x2F;  even make it here.

                    } else if ( &#x2F;^(url|email)$&#x2F;.test(inputElemType) ) {
                      &#x2F;&#x2F; Real url and email support comes with prebaked validation.
                      bool = inputElem.checkValidity &amp;&amp; inputElem.checkValidity() === false;

                    } else {
                      &#x2F;&#x2F; If the upgraded input compontent rejects the :) text, we got a winner
                      bool = inputElem.value != smile;
                    }
                }

                inputs[ props[i] ] = !!bool;
            }
            return inputs;
        })(&#x27;search tel url email datetime date month week time datetime-local number range color&#x27;.split(&#x27; &#x27;));
        &#x2F;*&gt;&gt;inputtypes*&#x2F;
    }
    &#x2F;*&gt;&gt;webforms*&#x2F;


    &#x2F;&#x2F; End of test definitions
    &#x2F;&#x2F; -----------------------



    &#x2F;&#x2F; Run through all tests and detect their support in the current UA.
    &#x2F;&#x2F; todo: hypothetically we could be doing an array of tests and use a basic loop here.
    for ( var feature in tests ) {
        if ( hasOwnProp(tests, feature) ) {
            &#x2F;&#x2F; run the test, throw the return value into the Modernizr,
            &#x2F;&#x2F;   then based on that boolean, define an appropriate className
            &#x2F;&#x2F;   and push it into an array of classes we&#x27;ll join later.
            featureName  = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();

            classes.push((Modernizr[featureName] ? &#x27;&#x27; : &#x27;no-&#x27;) + featureName);
        }
    }

    &#x2F;*&gt;&gt;webforms*&#x2F;
    &#x2F;&#x2F; input tests need to run.
    Modernizr.input || webforms();
    &#x2F;*&gt;&gt;webforms*&#x2F;


    &#x2F;**
     * addTest allows the user to define their own feature tests
     * the result will be added onto the Modernizr object,
     * as well as an appropriate className set on the html element
     *
     * @param feature - String naming the feature
     * @param test - Function returning true if feature is supported, false if not
     *&#x2F;
     Modernizr.addTest = function ( feature, test ) {
       if ( typeof feature == &#x27;object&#x27; ) {
         for ( var key in feature ) {
           if ( hasOwnProp( feature, key ) ) {
             Modernizr.addTest( key, feature[ key ] );
           }
         }
       } else {

         feature = feature.toLowerCase();

         if ( Modernizr[feature] !== undefined ) {
           &#x2F;&#x2F; we&#x27;re going to quit if you&#x27;re trying to overwrite an existing test
           &#x2F;&#x2F; if we were to allow it, we&#x27;d do this:
           &#x2F;&#x2F;   var re = new RegExp(&quot;\\b(no-)?&quot; + feature + &quot;\\b&quot;);
           &#x2F;&#x2F;   docElement.className = docElement.className.replace( re, &#x27;&#x27; );
           &#x2F;&#x2F; but, no rly, stuff &#x27;em.
           return Modernizr;
         }

         test = typeof test == &#x27;function&#x27; ? test() : test;

         if (typeof enableClasses !== &quot;undefined&quot; &amp;&amp; enableClasses) {
           docElement.className += &#x27; &#x27; + (test ? &#x27;&#x27; : &#x27;no-&#x27;) + feature;
         }
         Modernizr[feature] = test;

       }

       return Modernizr; &#x2F;&#x2F; allow chaining.
     };


    &#x2F;&#x2F; Reset modElem.cssText to nothing to reduce memory footprint.
    setCss(&#x27;&#x27;);
    modElem = inputElem = null;

    &#x2F;*&gt;&gt;shiv*&#x2F;
    &#x2F;*! HTML5 Shiv v3.6.1 | @afarkas @jdalton @jon_neal @rem | MIT&#x2F;GPL2 Licensed *&#x2F;
    ;(function(window, document) {
    &#x2F;*jshint evil:true *&#x2F;
      &#x2F;** Preset options *&#x2F;
      var options = window.html5 || {};

      &#x2F;** Used to skip problem elements *&#x2F;
      var reSkip = &#x2F;^&lt;|^(?:button|map|select|textarea|object|iframe|option|optgroup)$&#x2F;i;

      &#x2F;** Not all elements can be cloned in IE **&#x2F;
      var saveClones = &#x2F;^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$&#x2F;i;

      &#x2F;** Detect whether the browser supports default html5 styles *&#x2F;
      var supportsHtml5Styles;

      &#x2F;** Name of the expando, to work with multiple documents or to re-shiv one document *&#x2F;
      var expando = &#x27;_html5shiv&#x27;;

      &#x2F;** The id for the the documents expando *&#x2F;
      var expanID = 0;

      &#x2F;** Cached data for each document *&#x2F;
      var expandoData = {};

      &#x2F;** Detect whether the browser supports unknown elements *&#x2F;
      var supportsUnknownElements;

      (function() {
        try {
            var a = document.createElement(&#x27;a&#x27;);
            a.innerHTML = &#x27;&lt;xyz&gt;&lt;&#x2F;xyz&gt;&#x27;;
            &#x2F;&#x2F;if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
            supportsHtml5Styles = (&#x27;hidden&#x27; in a);

            supportsUnknownElements = a.childNodes.length == 1 || (function() {
              &#x2F;&#x2F; assign a false positive if unable to shiv
              (document.createElement)(&#x27;a&#x27;);
              var frag = document.createDocumentFragment();
              return (
                typeof frag.cloneNode == &#x27;undefined&#x27; ||
                typeof frag.createDocumentFragment == &#x27;undefined&#x27; ||
                typeof frag.createElement == &#x27;undefined&#x27;
              );
            }());
        } catch(e) {
          supportsHtml5Styles = true;
          supportsUnknownElements = true;
        }

      }());

      &#x2F;*--------------------------------------------------------------------------*&#x2F;

      &#x2F;**
       * Creates a style sheet with the given CSS text and adds it to the document.
       * @private
       * @param {Document} ownerDocument The document.
       * @param {String} cssText The CSS text.
       * @returns {StyleSheet} The style element.
       *&#x2F;
      function addStyleSheet(ownerDocument, cssText) {
        var p = ownerDocument.createElement(&#x27;p&#x27;),
            parent = ownerDocument.getElementsByTagName(&#x27;head&#x27;)[0] || ownerDocument.documentElement;

        p.innerHTML = &#x27;x&lt;style&gt;&#x27; + cssText + &#x27;&lt;&#x2F;style&gt;&#x27;;
        return parent.insertBefore(p.lastChild, parent.firstChild);
      }

      &#x2F;**
       * Returns the value of &#x60;html5.elements&#x60; as an array.
       * @private
       * @returns {Array} An array of shived element node names.
       *&#x2F;
      function getElements() {
        var elements = html5.elements;
        return typeof elements == &#x27;string&#x27; ? elements.split(&#x27; &#x27;) : elements;
      }

        &#x2F;**
       * Returns the data associated to the given document
       * @private
       * @param {Document} ownerDocument The document.
       * @returns {Object} An object of data.
       *&#x2F;
      function getExpandoData(ownerDocument) {
        var data = expandoData[ownerDocument[expando]];
        if (!data) {
            data = {};
            expanID++;
            ownerDocument[expando] = expanID;
            expandoData[expanID] = data;
        }
        return data;
      }

      &#x2F;**
       * returns a shived element for the given nodeName and document
       * @memberOf html5
       * @param {String} nodeName slug of the element
       * @param {Document} ownerDocument The context document.
       * @returns {Object} The shived element.
       *&#x2F;
      function createElement(nodeName, ownerDocument, data){
        if (!ownerDocument) {
            ownerDocument = document;
        }
        if(supportsUnknownElements){
            return ownerDocument.createElement(nodeName);
        }
        if (!data) {
            data = getExpandoData(ownerDocument);
        }
        var node;

        if (data.cache[nodeName]) {
            node = data.cache[nodeName].cloneNode();
        } else if (saveClones.test(nodeName)) {
            node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
        } else {
            node = data.createElem(nodeName);
        }

        &#x2F;&#x2F; Avoid adding some elements to fragments in IE &lt; 9 because
        &#x2F;&#x2F; * Attributes like &#x60;slug&#x60; or &#x60;type&#x60; cannot be set&#x2F;changed once an element
        &#x2F;&#x2F;   is inserted into a document&#x2F;fragment
        &#x2F;&#x2F; * Link elements with &#x60;src&#x60; attributes that are inaccessible, as with
        &#x2F;&#x2F;   a 403 response, will cause the tab&#x2F;window to crash
        &#x2F;&#x2F; * Script elements appended to fragments will execute when their &#x60;src&#x60;
        &#x2F;&#x2F;   or &#x60;text&#x60; property is set
        return node.canHaveChildren &amp;&amp; !reSkip.test(nodeName) ? data.frag.appendChild(node) : node;
      }

      &#x2F;**
       * returns a shived DocumentFragment for the given document
       * @memberOf html5
       * @param {Document} ownerDocument The context document.
       * @returns {Object} The shived DocumentFragment.
       *&#x2F;
      function createDocumentFragment(ownerDocument, data){
        if (!ownerDocument) {
            ownerDocument = document;
        }
        if(supportsUnknownElements){
            return ownerDocument.createDocumentFragment();
        }
        data = data || getExpandoData(ownerDocument);
        var clone = data.frag.cloneNode(),
            i = 0,
            elems = getElements(),
            l = elems.length;
        for(;i&lt;l;i++){
            clone.createElement(elems[i]);
        }
        return clone;
      }

      &#x2F;**
       * Shivs the &#x60;createElement&#x60; and &#x60;createDocumentFragment&#x60; methods of the document.
       * @private
       * @param {Document|DocumentFragment} ownerDocument The document.
       * @param {Object} data of the document.
       *&#x2F;
      function shivMethods(ownerDocument, data) {
        if (!data.cache) {
            data.cache = {};
            data.createElem = ownerDocument.createElement;
            data.createFrag = ownerDocument.createDocumentFragment;
            data.frag = data.createFrag();
        }


        ownerDocument.createElement = function(nodeName) {
          &#x2F;&#x2F;abort shiv
          if (!html5.shivMethods) {
              return data.createElem(nodeName);
          }
          return createElement(nodeName, ownerDocument, data);
        };

        ownerDocument.createDocumentFragment = Function(&#x27;h,f&#x27;, &#x27;return function(){&#x27; +
          &#x27;var n=f.cloneNode(),c=n.createElement;&#x27; +
          &#x27;h.shivMethods&amp;&amp;(&#x27; +
            &#x2F;&#x2F; unroll the &#x60;createElement&#x60; calls
            getElements().join().replace(&#x2F;\w+&#x2F;g, function(nodeName) {
              data.createElem(nodeName);
              data.frag.createElement(nodeName);
              return &#x27;c(&quot;&#x27; + nodeName + &#x27;&quot;)&#x27;;
            }) +
          &#x27;);return n}&#x27;
        )(html5, data.frag);
      }

      &#x2F;*--------------------------------------------------------------------------*&#x2F;

      &#x2F;**
       * Shivs the given document.
       * @memberOf html5
       * @param {Document} ownerDocument The document to shiv.
       * @returns {Document} The shived document.
       *&#x2F;
      function shivDocument(ownerDocument) {
        if (!ownerDocument) {
            ownerDocument = document;
        }
        var data = getExpandoData(ownerDocument);

        if (html5.shivCSS &amp;&amp; !supportsHtml5Styles &amp;&amp; !data.hasCSS) {
          data.hasCSS = !!addStyleSheet(ownerDocument,
            &#x2F;&#x2F; corrects block display not defined in IE6&#x2F;7&#x2F;8&#x2F;9
            &#x27;article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}&#x27; +
            &#x2F;&#x2F; adds styling not present in IE6&#x2F;7&#x2F;8&#x2F;9
            &#x27;mark{background:#FF0;color:#000}&#x27;
          );
        }
        if (!supportsUnknownElements) {
          shivMethods(ownerDocument, data);
        }
        return ownerDocument;
      }

      &#x2F;*--------------------------------------------------------------------------*&#x2F;

      &#x2F;**
       * The &#x60;html5&#x60; object is exposed so that more elements can be shived and
       * existing shiving can be detected on iframes.
       * @type Object
       * @example
       *
       * &#x2F;&#x2F; options can be changed before the script is included
       * html5 = { &#x27;elements&#x27;: &#x27;mark section&#x27;, &#x27;shivCSS&#x27;: false, &#x27;shivMethods&#x27;: false };
       *&#x2F;
      var html5 = {

        &#x2F;**
         * An array or space separated string of node names of the elements to shiv.
         * @memberOf html5
         * @type Array|String
         *&#x2F;
        &#x27;elements&#x27;: options.elements || &#x27;abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video&#x27;,

        &#x2F;**
         * A flag to indicate that the HTML5 style sheet should be inserted.
         * @memberOf html5
         * @type Boolean
         *&#x2F;
        &#x27;shivCSS&#x27;: (options.shivCSS !== false),

        &#x2F;**
         * Is equal to true if a browser supports creating unknown&#x2F;HTML5 elements
         * @memberOf html5
         * @type boolean
         *&#x2F;
        &#x27;supportsUnknownElements&#x27;: supportsUnknownElements,

        &#x2F;**
         * A flag to indicate that the document&#x27;s &#x60;createElement&#x60; and &#x60;createDocumentFragment&#x60;
         * methods should be overwritten.
         * @memberOf html5
         * @type Boolean
         *&#x2F;
        &#x27;shivMethods&#x27;: (options.shivMethods !== false),

        &#x2F;**
         * A string to describe the type of &#x60;html5&#x60; object (&quot;default&quot; or &quot;default print&quot;).
         * @memberOf html5
         * @type String
         *&#x2F;
        &#x27;type&#x27;: &#x27;default&#x27;,

        &#x2F;&#x2F; shivs the document according to the specified &#x60;html5&#x60; object options
        &#x27;shivDocument&#x27;: shivDocument,

        &#x2F;&#x2F;creates a shived element
        createElement: createElement,

        &#x2F;&#x2F;creates a shived documentFragment
        createDocumentFragment: createDocumentFragment
      };

      &#x2F;*--------------------------------------------------------------------------*&#x2F;

      &#x2F;&#x2F; expose html5
      window.html5 = html5;

      &#x2F;&#x2F; shiv the document
      shivDocument(document);

    }(this, document));
    &#x2F;*&gt;&gt;shiv*&#x2F;

    &#x2F;&#x2F; Assign private properties to the return object with prefix
    Modernizr._version      = version;

    &#x2F;&#x2F; expose these for the plugin API. Look in the source for how to join() them against your input
    &#x2F;*&gt;&gt;prefixes*&#x2F;
    Modernizr._prefixes     = prefixes;
    &#x2F;*&gt;&gt;prefixes*&#x2F;
    &#x2F;*&gt;&gt;domprefixes*&#x2F;
    Modernizr._domPrefixes  = domPrefixes;
    Modernizr._cssomPrefixes  = cssomPrefixes;
    &#x2F;*&gt;&gt;domprefixes*&#x2F;

    &#x2F;*&gt;&gt;mq*&#x2F;
    &#x2F;&#x2F; Modernizr.mq tests a given media query, live against the current state of the window
    &#x2F;&#x2F; A few important notes:
    &#x2F;&#x2F;   * If a browser does not support media queries at all (eg. oldIE) the mq() will always return false
    &#x2F;&#x2F;   * A max-width or orientation query will be evaluated against the current state, which may change later.
    &#x2F;&#x2F;   * You must specify values. Eg. If you are testing support for the min-width media query use:
    &#x2F;&#x2F;       Modernizr.mq(&#x27;(min-width:0)&#x27;)
    &#x2F;&#x2F; usage:
    &#x2F;&#x2F; Modernizr.mq(&#x27;only screen and (max-width:768)&#x27;)
    Modernizr.mq            = testMediaQuery;
    &#x2F;*&gt;&gt;mq*&#x2F;

    &#x2F;*&gt;&gt;hasevent*&#x2F;
    &#x2F;&#x2F; Modernizr.hasEvent() detects support for a given event, with an optional element to test on
    &#x2F;&#x2F; Modernizr.hasEvent(&#x27;gesturestart&#x27;, elem)
    Modernizr.hasEvent      = isEventSupported;
    &#x2F;*&gt;&gt;hasevent*&#x2F;

    &#x2F;*&gt;&gt;testprop*&#x2F;
    &#x2F;&#x2F; Modernizr.testProp() investigates whether a given style property is recognized
    &#x2F;&#x2F; Note that the property names must be provided in the camelCase variant.
    &#x2F;&#x2F; Modernizr.testProp(&#x27;pointerEvents&#x27;)
    Modernizr.testProp      = function(prop){
        return testProps([prop]);
    };
    &#x2F;*&gt;&gt;testprop*&#x2F;

    &#x2F;*&gt;&gt;testallprops*&#x2F;
    &#x2F;&#x2F; Modernizr.testAllProps() investigates whether a given style property,
    &#x2F;&#x2F;   or any of its vendor-prefixed variants, is recognized
    &#x2F;&#x2F; Note that the property names must be provided in the camelCase variant.
    &#x2F;&#x2F; Modernizr.testAllProps(&#x27;boxSizing&#x27;)
    Modernizr.testAllProps  = testPropsAll;
    &#x2F;*&gt;&gt;testallprops*&#x2F;


    &#x2F;*&gt;&gt;teststyles*&#x2F;
    &#x2F;&#x2F; Modernizr.testStyles() allows you to add custom styles to the document and test an element afterwards
    &#x2F;&#x2F; Modernizr.testStyles(&#x27;#modernizr { position:absolute }&#x27;, function(elem, rule){ ... })
    Modernizr.testStyles    = injectElementWithStyles;
    &#x2F;*&gt;&gt;teststyles*&#x2F;


    &#x2F;*&gt;&gt;prefixed*&#x2F;
    &#x2F;&#x2F; Modernizr.prefixed() returns the prefixed or nonprefixed property slug variant of your input
    &#x2F;&#x2F; Modernizr.prefixed(&#x27;boxSizing&#x27;) &#x2F;&#x2F; &#x27;MozBoxSizing&#x27;

    &#x2F;&#x2F; Properties must be passed as dom-style camelcase, rather than &#x60;box-sizing&#x60; hypentated style.
    &#x2F;&#x2F; Return values will also be the camelCase variant, if you need to translate that to hypenated style use:
    &#x2F;&#x2F;
    &#x2F;&#x2F;     str.replace(&#x2F;([A-Z])&#x2F;g, function(str,m1){ return &#x27;-&#x27; + m1.toLowerCase(); }).replace(&#x2F;^ms-&#x2F;,&#x27;-ms-&#x27;);

    &#x2F;&#x2F; If you&#x27;re trying to ascertain which transition end event to bind to, you might do something like...
    &#x2F;&#x2F;
    &#x2F;&#x2F;     var transEndEventNames = {
    &#x2F;&#x2F;       &#x27;WebkitTransition&#x27; : &#x27;webkitTransitionEnd&#x27;,
    &#x2F;&#x2F;       &#x27;MozTransition&#x27;    : &#x27;transitionend&#x27;,
    &#x2F;&#x2F;       &#x27;OTransition&#x27;      : &#x27;oTransitionEnd&#x27;,
    &#x2F;&#x2F;       &#x27;msTransition&#x27;     : &#x27;MSTransitionEnd&#x27;,
    &#x2F;&#x2F;       &#x27;transition&#x27;       : &#x27;transitionend&#x27;
    &#x2F;&#x2F;     },
    &#x2F;&#x2F;     transEndEventName = transEndEventNames[ Modernizr.prefixed(&#x27;transition&#x27;) ];

    Modernizr.prefixed      = function(prop, obj, elem){
      if(!obj) {
        return testPropsAll(prop, &#x27;pfx&#x27;);
      } else {
        &#x2F;&#x2F; Testing DOM property e.g. Modernizr.prefixed(&#x27;requestAnimationFrame&#x27;, window) &#x2F;&#x2F; &#x27;mozRequestAnimationFrame&#x27;
        return testPropsAll(prop, obj, elem);
      }
    };
    &#x2F;*&gt;&gt;prefixed*&#x2F;


    &#x2F;*&gt;&gt;cssclasses*&#x2F;
    &#x2F;&#x2F; Remove &quot;no-js&quot; class from &lt;html&gt; element, if it exists:
    docElement.className = docElement.className.replace(&#x2F;(^|\s)no-js(\s|$)&#x2F;, &#x27;$1$2&#x27;) +

                            &#x2F;&#x2F; Add the new classes to the &lt;html&gt; element.
                            (enableClasses ? &#x27; js &#x27; + classes.join(&#x27; &#x27;) : &#x27;&#x27;);
    &#x2F;*&gt;&gt;cssclasses*&#x2F;

    return Modernizr;

})(this, this.document);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
